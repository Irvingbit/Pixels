<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementación y Análisis de Perceptrones - Grupo Pixels</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            image-rendering: pixelated;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #2d3436;
            border: 8px solid #000;
            box-shadow: 0 0 0 4px #fff, 0 0 0 8px #000;
        }
        
        /* HEADER STYLES */
        .header {
            background: linear-gradient(180deg, #5dade2 0%, #3498db 50%, #48c9b0 100%);
            padding: 40px;
            text-align: center;
            border-bottom: 8px solid #000;
            position: relative;
            overflow: hidden;
            min-height: 400px;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 49px, rgba(0,0,0,0.1) 49px, rgba(0,0,0,0.1) 50px),
                repeating-linear-gradient(0deg, transparent, transparent 49px, rgba(0,0,0,0.1) 49px, rgba(0,0,0,0.1) 50px);
            pointer-events: none;
        }
        
        /* MARIO ELEMENTS */
        .mario-block {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #f39c12;
            border: 4px solid #000;
            box-shadow: inset 0 0 0 4px #f1c40f;
        }
        
        .mario-block::after {
            content: '?';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #000;
        }
        
        .mario-block.top-left { top: 20px; left: 20px; }
        .mario-block.top-right { top: 20px; right: 20px; }
        .mario-block.bottom-left { bottom: 20px; left: 80px; }
        .mario-block.bottom-right { bottom: 20px; right: 80px; }
        
        .mario-coin {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #f39c12;
            border-radius: 50%;
            border: 3px solid #000;
            box-shadow: inset 0 0 0 3px #f1c40f;
            animation: coinFloat 3s ease-in-out infinite;
        }
        
        @keyframes coinFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(180deg); }
        }
        
        .coin1 { top: 80px; left: 100px; animation-delay: 0s; }
        .coin2 { top: 80px; right: 100px; animation-delay: 0.5s; }
        .coin3 { bottom: 80px; left: 150px; animation-delay: 1s; }
        .coin4 { bottom: 80px; right: 150px; animation-delay: 1.5s; }
        
        .pipe {
            position: absolute;
            bottom: 0;
            width: 60px;
            height: 100px;
            background: #27ae60;
            border: 4px solid #000;
            border-bottom: none;
        }
        
        .pipe::before {
            content: '';
            position: absolute;
            top: -15px;
            left: -8px;
            right: -8px;
            height: 20px;
            background: #2ecc71;
            border: 4px solid #000;
            border-radius: 8px 8px 0 0;
        }
        
        .pipe.left { left: 50px; }
        .pipe.right { right: 50px; }
        
        .cloud {
            position: absolute;
            background: #fff;
            border: 3px solid #000;
            border-radius: 50%;
            width: 80px;
            height: 30px;
        }
        
        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: #fff;
            border: 3px solid #000;
            border-radius: 50%;
        }
        
        .cloud::before {
            width: 40px;
            height: 40px;
            top: -20px;
            left: 10px;
        }
        
        .cloud::after {
            width: 50px;
            height: 35px;
            top: -15px;
            right: 10px;
        }
        
        .cloud1 { top: 40px; left: 15%; }
        .cloud2 { top: 60px; right: 15%; }
        
        /* HEADER TEXT */
        h1 {
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 4px 4px 0 #e74c3c, 6px 6px 0 #000;
            margin-bottom: 20px;
            line-height: 1.8;
            position: relative;
            z-index: 10;
        }
        
        .subtitle {
            font-size: 0.7rem;
            color: #fff;
            background: rgba(231, 76, 60, 0.9);
            padding: 15px;
            border: 4px solid #000;
            margin: 10px auto;
            max-width: 600px;
            line-height: 1.6;
            position: relative;
            z-index: 10;
            box-shadow: 4px 4px 0 #000;
        }
        
        .authors {
            font-size: 0.5rem;
            color: #fff;
            background: rgba(52, 152, 219, 0.9);
            padding: 20px;
            border: 4px solid #000;
            margin: 20px auto 0;
            max-width: 700px;
            line-height: 1.8;
            position: relative;
            z-index: 10;
            box-shadow: 4px 4px 0 #000;
        }
        
        .authors strong {
            color: #f39c12;
            text-shadow: 2px 2px 0 #000;
        }
        
        /* NAVIGATION BUTTONS */
        .nav-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            padding: 30px;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
        }
        
        .pixel-button {
            padding: 15px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: #fff;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border: 4px solid #000;
            cursor: pointer;
            transition: all 0.1s;
            text-align: center;
            position: relative;
            box-shadow: 4px 4px 0 #000;
        }
        
        .pixel-button:hover {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #000;
        }
        
        .pixel-button:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 #000;
        }
        
        .pixel-button.active {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            box-shadow: inset 4px 4px 0 rgba(0,0,0,0.3);
        }
        
        /* CONTENT SECTIONS */
        .content-section {
            display: none;
            padding: 40px;
            background: linear-gradient(135deg, #ecf0f1 0%, #bdc3c7 100%);
            border-top: 8px solid #000;
            min-height: 500px;
        }
        
        .content-section.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* TYPOGRAPHY */
        h2 {
            font-size: 1.2rem;
            color: #e74c3c;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0 #f39c12, 5px 5px 0 #000;
            border-bottom: 4px solid #e74c3c;
            padding-bottom: 15px;
        }
        
        h3 {
            font-size: 0.8rem;
            color: #2ecc71;
            margin: 25px 0 15px;
            text-shadow: 2px 2px 0 #000;
        }
        
        p, li {
            font-size: 0.5rem;
            line-height: 2;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        ul {
            list-style: none;
            padding-left: 20px;
        }
        
        ul li:before {
            content: "★ ";
            color: #f39c12;
            margin-right: 10px;
        }
        
        strong {
            color: #e74c3c;
        }
        
        /* CARDS AND BOXES */
        .model-card {
            background: #fff;
            border: 4px solid #000;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 6px 6px 0 #3498db;
            position: relative;
        }
        
        .model-card::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 2px solid #f39c12;
            pointer-events: none;
        }
        
        .model-card h3 {
            color: #e74c3c;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-box {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: #fff;
            padding: 20px;
            border: 4px solid #000;
            text-align: center;
            box-shadow: 4px 4px 0 #000;
            position: relative;
        }
        
        .stat-box::after {
            content: '★';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
            color: #f39c12;
        }
        
        .stat-value {
            font-size: 1.5rem;
            margin: 15px 0;
            text-shadow: 3px 3px 0 #000;
        }
        
        .stat-label {
            font-size: 0.5rem;
        }
        
        .conclusion-box {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: #fff;
            padding: 30px;
            border: 6px solid #000;
            margin: 20px 0;
            box-shadow: 6px 6px 0 #000;
            position: relative;
        }
        
        .conclusion-box::before {
            content: '►';
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2rem;
            color: #f39c12;
        }
        
        .conclusion-box h3 {
            color: #f39c12;
            text-shadow: 2px 2px 0 #000;
            margin-left: 40px;
        }
        
        .conclusion-box p {
            color: #fff;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
            margin-left: 40px;
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            h1 { font-size: 1rem; }
            h2 { font-size: 0.9rem; }
            h3 { font-size: 0.7rem; }
            p, li { font-size: 0.45rem; }
            .pixel-button { font-size: 0.5rem; padding: 12px 15px; }
            .mario-block { width: 30px; height: 30px; }
            .pipe { width: 40px; height: 70px; }
            .cloud { width: 60px; height: 25px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- HEADER SECTION -->
        <div class="header">
            <div class="mario-block top-left"></div>
            <div class="mario-block top-right"></div>
            <div class="mario-block bottom-left"></div>
            <div class="mario-block bottom-right"></div>
            
            <div class="mario-coin coin1"></div>
            <div class="mario-coin coin2"></div>
            <div class="mario-coin coin3"></div>
            <div class="mario-coin coin4"></div>
            
            <div class="cloud cloud1"></div>
            <div class="cloud cloud2"></div>
            
            <div class="pipe left"></div>
            <div class="pipe right"></div>
            
            <h1>IMPLEMENTACIÓN Y ANÁLISIS<br>DE PERCEPTRONES</h1>
            
            <div class="subtitle">
                ASIGNATURA: CONSTRUCCIÓN DE SOFTWARE<br>
                NRC: 59116<br>
                DOCENTE: ESPETIA HUAMANGA HUGO
            </div>
            
            <div class="authors">
                <strong>★ GRUPO PIXELS ★</strong><br><br>
                ► HUANCA PALOMINO JOSE YOHEL<br>
                ► HUACHO CRIOLLO GRIMALDO<br>
                ► PAIVA PAREDES HIRVING RODRIGO<br>
                ► CONDORI UMPIRE ALDAIR FABRICIO<br>
                ► HUAMAN SEQUEIROS DAVID JHONATHAN
            </div>
        </div>
        
        <!-- NAVIGATION -->
        <div class="nav-buttons">
            <button class="pixel-button active" onclick="showSection('intro')">INTRODUCCIÓN</button>
            <button class="pixel-button" onclick="showSection('metodologia')">METODOLOGÍA</button>
            <button class="pixel-button" onclick="showSection('modelo1')">PERCEPTRÓN 1</button>
            <button class="pixel-button" onclick="showSection('modelo2')">PERCEPTRÓN 2</button>
            <button class="pixel-button" onclick="showSection('modelo3')">PERCEPTRÓN 3</button>
            <button class="pixel-button" onclick="showSection('resultados')">RESULTADOS</button>
            <button class="pixel-button" onclick="showSection('conclusiones')">CONCLUSIONES</button>
        </div>
        
        <!-- CONTENT SECTIONS -->
        
        <!-- INTRODUCCIÓN -->
        <div id="intro" class="content-section active">
            <h2>► INTRODUCCIÓN</h2>
            
            <p>
                El perceptrón es uno de los algoritmos fundamentales en el aprendizaje automático, 
                representando la base de las redes neuronales modernas. Este proyecto implementa y 
                analiza tres variaciones de perceptrones para resolver un problema de clasificación 
                binaria en el ámbito médico.
            </p>
            
            <h3>◆ OBJETIVO DEL PROYECTO</h3>
            <p>
                Demostrar la capacidad de implementar, entrenar y evaluar modelos de perceptrón desde 
                cero, analizando cómo las variaciones en parámetros (tasa de aprendizaje) y 
                características (feature selection) afectan el rendimiento del modelo.
            </p>
            
            <h3>◆ DATASET UTILIZADO</h3>
            <p>
                <strong>Heart Failure Clinical Records Dataset</strong> - Un dataset médico que contiene 
                registros clínicos de pacientes con insuficiencia cardíaca. El objetivo es predecir la 
                variable DEATH_EVENT (fallecimiento del paciente) basándose en características clínicas.
            </p>
            
            <div class="model-card">
                <h3>CARACTERÍSTICAS DEL DATASET</h3>
                <ul>
                    <li>299 registros de pacientes</li>
                    <li>13 características clínicas originales</li>
                    <li>Clasificación binaria: 0 (Sobrevive) / 1 (Fallece)</li>
                    <li>Variables numéricas: edad, creatinina, fracción de eyección, etc.</li>
                    <li>División aplicada: 80% entrenamiento, 20% prueba</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>CARACTERÍSTICAS PRINCIPALES IDENTIFICADAS</h3>
                <ul>
                    <li><strong>ejection_fraction:</strong> Fracción de eyección del corazón</li>
                    <li><strong>serum_creatinine:</strong> Nivel de creatinina en sangre</li>
                    <li><strong>age:</strong> Edad del paciente</li>
                    <li><strong>time:</strong> Período de seguimiento</li>
                </ul>
            </div>
        </div>
        
        <!-- METODOLOGÍA -->
        <div id="metodologia" class="content-section">
            <h2>► METODOLOGÍA</h2>
            
            <h3>◆ PREPROCESAMIENTO DE DATOS</h3>
            <div class="model-card">
                <h3>PASOS REALIZADOS</h3>
                <ul>
                    <li>Análisis exploratorio de datos (EDA)</li>
                    <li>Análisis de correlación con mapa de calor</li>
                    <li>Selección de características relevantes</li>
                    <li>Normalización con StandardScaler (media=0, desviación=1)</li>
                    <li>División estratificada 80/20 (train/test)</li>
                    <li>Conversión de etiquetas: 0→-1, 1→1 para el perceptrón</li>
                </ul>
            </div>
            
            <h3>◆ IMPLEMENTACIÓN DEL PERCEPTRÓN</h3>
            <div class="model-card">
                <h3>ALGORITMO IMPLEMENTADO DESDE CERO</h3>
                <p>Clase Perceptron con los siguientes componentes:</p>
                <ul>
                    <li><strong>Inicialización:</strong> Pesos en cero, bias en cero</li>
                    <li><strong>Función de activación:</strong> Signo (retorna 1 o -1)</li>
                    <li><strong>Regla de actualización:</strong> Solo cuando target × net_input ≤ 0</li>
                    <li><strong>Actualización de pesos:</strong> w += α × target × xi</li>
                    <li><strong>Actualización de bias:</strong> b += α × target</li>
                    <li><strong>Criterio de parada:</strong> Máximo de épocas o convergencia total</li>
                </ul>
            </div>
            
            <h3>◆ MÉTRICAS DE EVALUACIÓN</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">ACCURACY</div>
                    <div class="stat-value">%</div>
                    <div class="stat-label">Precisión Global</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">MATRIZ DE CONFUSIÓN</div>
                    <div class="stat-value">■</div>
                    <div class="stat-label">VP, FP, VN, FN</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">ERRORES POR ÉPOCA</div>
                    <div class="stat-value">↓</div>
                    <div class="stat-label">Convergencia</div>
                </div>
            </div>
            
            <div class="model-card">
                <h3>HERRAMIENTAS UTILIZADAS</h3>
                <ul>
                    <li>Python 3.x con Google Colab</li>
                    <li>NumPy para operaciones vectoriales</li>
                    <li>Pandas para manipulación de datos</li>
                    <li>Scikit-learn para preprocesamiento y métricas</li>
                    <li>Matplotlib y Seaborn para visualizaciones</li>
                </ul>
            </div>
        </div>
        
        <!-- MODELO 1 -->
        <div id="modelo1" class="content-section">
            <h2>► PERCEPTRÓN 1: BÁSICO</h2>
            
            <div class="model-card">
                <h3>CONFIGURACIÓN</h3>
                <ul>
                    <li><strong>Arquitectura:</strong> Perceptrón simple (una capa)</li>
                    <li><strong>Tasa de aprendizaje (α):</strong> 0.01</li>
                    <li><strong>Épocas máximas:</strong> 100</li>
                    <li><strong>Características:</strong> 4 features seleccionadas</li>
                    <li><strong>Features usadas:</strong> ejection_fraction, serum_creatinine, age, time</li>
                    <li><strong>División datos:</strong> 80% entrenamiento, 20% prueba</li>
                </ul>
            </div>
            
            <h3>◆ CARACTERÍSTICAS DEL MODELO</h3>
            <p>
                Este modelo representa la implementación más directa del algoritmo del perceptrón, 
                utilizando una tasa de aprendizaje estándar (α=0.01) para asegurar convergencia estable. 
                Utiliza las etiquetas -1 y 1 con la regla de actualización clásica del perceptrón.
            </p>
            
            <h3>◆ IMPLEMENTACIÓN</h3>
            <div class="model-card">
                <ul>
                    <li>Inicialización: Pesos en cero, bias en cero</li>
                    <li>Función de activación: Signo (retorna 1 o -1)</li>
                    <li>Regla de actualización: Solo cuando target * net_input ≤ 0</li>
                    <li>Criterio de parada: 100 épocas o convergencia total</li>
                    <li>Preprocesamiento: StandardScaler para normalización</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>VENTAJAS</h3>
                <ul>
                    <li>Balance entre velocidad y estabilidad de convergencia</li>
                    <li>Tasa de aprendizaje moderada evita oscilaciones</li>
                    <li>Fácil de interpretar y depurar</li>
                    <li>Converge en pocas épocas para datos linealmente separables</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>DESVENTAJAS</h3>
                <ul>
                    <li>Limitado a problemas linealmente separables</li>
                    <li>Sensible a características no normalizadas</li>
                    <li>No proporciona probabilidades, solo clasificación binaria</li>
                    <li>Requiere ajuste manual de hiperparámetros</li>
                </ul>
            </div>
        </div>
        
        <!-- MODELO 2 -->
        <div id="modelo2" class="content-section">
            <h2>► PERCEPTRÓN 2: TASA DE APRENDIZAJE MODIFICADA</h2>
            
            <div class="model-card">
                <h3>CONFIGURACIÓN</h3>
                <ul>
                    <li><strong>Arquitectura:</strong> Perceptrón simple (una capa)</li>
                    <li><strong>Tasa de aprendizaje (α):</strong> 0.001 (10x menor)</li>
                    <li><strong>Épocas máximas:</strong> 100</li>
                    <li><strong>Características:</strong> 4 features (iguales al Modelo 1)</li>
                    <li><strong>Features usadas:</strong> ejection_fraction, serum_creatinine, age, time</li>
                    <li><strong>Estrategia:</strong> Pasos de actualización más pequeños y conservadores</li>
                </ul>
            </div>
            
            <h3>◆ IMPACTO DE LA TASA DE APRENDIZAJE</h3>
            <p>
                Este modelo utiliza una tasa de aprendizaje significativamente menor (α=0.001) en 
                comparación con el Modelo 1 (α=0.01). El objetivo es observar cómo pasos más pequeños 
                afectan la velocidad de convergencia y la precisión final del modelo.
            </p>
            
            <h3>◆ EXPERIMENTO ADICIONAL: TASA ALTA</h3>
            <div class="model-card">
                <p>
                    También se experimentó con una tasa de aprendizaje muy alta (α=0.5) para comparar 
                    tres escenarios diferentes de velocidad de convergencia.
                </p>
                <ul>
                    <li><strong>α = 0.5:</strong> Convergencia rápida pero inestable</li>
                    <li><strong>α = 0.01:</strong> Balance óptimo (Modelo 1)</li>
                    <li><strong>α = 0.001:</strong> Convergencia lenta pero suave (Modelo 2)</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>VENTAJAS DE α = 0.001</h3>
                <ul>
                    <li>Mayor estabilidad en la convergencia</li>
                    <li>Menos oscilaciones durante el entrenamiento</li>
                    <li>Ajuste fino de los pesos</li>
                    <li>Mejor para datasets con ruido</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>DESVENTAJAS DE α = 0.001</h3>
                <ul>
                    <li>Convergencia extremadamente lenta</li>
                    <li>Requiere muchas más épocas</li>
                    <li>Puede no alcanzar el óptimo en tiempo limitado</li>
                    <li>Mayor costo computacional</li>
                </ul>
            </div>
            
            <h3>◆ VARIANTE: DECAIMIENTO ADAPTATIVO</h3>
            <div class="model-card">
                <p>
                    Se implementó también una variante con decaimiento de tasa de aprendizaje:
                </p>
                <ul>
                    <li><strong>α inicial:</strong> 0.1</li>
                    <li><strong>Decaimiento:</strong> α = α₀ / (1 + decay × época)</li>
                    <li><strong>Ventaja:</strong> Comienza rápido y termina con ajuste fino</li>
                    <li><strong>Resultado:</strong> Mejor balance entre velocidad y precisión</li>
                </ul>
            </div>
        </div>
        
        <!-- MODELO 3 -->
        <div id="modelo3" class="content-section">
            <h2>► PERCEPTRÓN 3: REDUCCIÓN DE CARACTERÍSTICAS</h2>
            
            <div class="model-card">
                <h3>CONFIGURACIÓN</h3>
                <ul>
                    <li><strong>Arquitectura:</strong> Perceptrón simple (una capa)</li>
                    <li><strong>Tasa de aprendizaje (α):</strong> 0.01</li>
                    <li><strong>Épocas máximas:</strong> 100</li>
                    <li><strong>Características:</strong> 2 features seleccionadas (reducción del 50%)</li>
                    <li><strong>Features usadas:</strong> ejection_fraction, serum_creatinine</li>
                    <li><strong>Método de selección:</strong> Análisis de correlación con DEATH_EVENT</li>
                </ul>
            </div>
            
            <h3>◆ PROCESO DE SELECCIÓN DE CARACTERÍSTICAS</h3>
            <p>
                Este modelo utiliza un subconjunto reducido de características, seleccionadas mediante 
                análisis de correlación con la variable objetivo DEATH_EVENT. Se priorizaron las 
                características con mayor poder predictivo.
            </p>
            
            <div class="model-card">
                <h3>ANÁLISIS DE CORRELACIÓN</h3>
                <p>Se realizó un mapa de calor de correlaciones para identificar las features más relevantes:</p>
                <ul>
                    <li><strong>time:</strong> Mayor correlación con DEATH_EVENT</li>
                    <li><strong>serum_creatinine:</strong> Segunda característica más importante</li>
                    <li><strong>ejection_fraction:</strong> Correlación negativa significativa</li>
                    <li><strong>age:</strong> Correlación moderada con el objetivo</li>
                </ul>
                <p>Para el Modelo 3 se seleccionaron solo las 2 características más correlacionadas.</p>
            </div>
            
            <h3>◆ COMPARACIÓN: 4 vs 2 CARACTERÍSTICAS</h3>
            <div class="model-card">
                <ul>
                    <li><strong>Modelo 1 y 2:</strong> 4 features (ejection_fraction, serum_creatinine, age, time)</li>
                    <li><strong>Modelo 3:</strong> 2 features (ejection_fraction, serum_creatinine)</li>
                    <li><strong>Reducción:</strong> 50% de las características</li>
                    <li><strong>Objetivo:</strong> Evaluar si menos features mejoran la generalización</li>
                </ul>
            </div>
            
            <h3>◆ VENTAJAS DE LA REDUCCIÓN</h3>
            <div class="model-card">
                <ul>
                    <li>Reduce significativamente el riesgo de sobreajuste</li>
                    <li>Mejora la interpretabilidad del modelo (2D visualizable)</li>
                    <li>Disminuye el costo computacional</li>
                    <li>Elimina ruido de características menos relevantes</li>
                    <li>Permite visualizar la frontera de decisión en 2D</li>
                    <li>Entrenamiento más rápido con menos parámetros</li>
                </ul>
            </div>
            
            <h3>◆ VISUALIZACIÓN DE FRONTERA DE DECISIÓN</h3>
            <div class="model-card">
                <p>
                    Una ventaja clave del Modelo 3 es que, al usar solo 2 características, 
                    podemos visualizar fácilmente la frontera de decisión del perceptrón en un 
                    gráfico de dispersión 2D.
                </p>
                <ul>
                    <li><strong>Eje X:</strong> ejection_fraction (fracción de eyección)</li>
                    <li><strong>Eje Y:</strong> serum_creatinine (creatinina sérica)</li>
                    <li><strong>Línea verde:</strong> Frontera de decisión del perceptrón</li>
                    <li><strong>Puntos rojos:</strong> Clase 1 (Muerte)</li>
                    <li><strong>Puntos azules:</strong> Clase -1 (Sobrevive)</li>
                </ul>
            </div>
        </div>
        
        <!-- RESULTADOS -->
        <div id="resultados" class="content-section">
            <h2>► RESULTADOS COMPARATIVOS</h2>
            
            <h3>◆ CONFIGURACIONES FINALES</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">MODELO 1: BÁSICO</div>
                    <div class="stat-value">α = 0.01</div>
                    <div class="stat-label">4 CARACTERÍSTICAS</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">MODELO 2: MODIFICADO</div>
                    <div class="stat-value">α = 0.001</div>
                    <div class="stat-label">4 CARACTERÍSTICAS</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">MODELO 3: REDUCIDO</div>
                    <div class="stat-value">α = 0.01</div>
                    <div class="stat-label">2 CARACTERÍSTICAS</div>
                </div>
            </div>
            
            <h3>◆ ANÁLISIS DE CONVERGENCIA</h3>
            <div class="model-card">
                <h3>CURVAS DE ERROR POR ÉPOCA</h3>
                <p>
                    Se graficaron los errores de clasificación durante el entrenamiento para los 
                    tres modelos. Las observaciones clave son:
                </p>
                <ul>
                    <li><strong>Modelo 1 (α=0.01, 4F):</strong> Convergencia moderada y estable</li>
                    <li><strong>Modelo 2 (α=0.001, 4F):</strong> Convergencia muy lenta, pasos pequeños</li>
                    <li><strong>Modelo 3 (α=0.01, 2F):</strong> Convergencia rápida con menos parámetros</li>
                </ul>
                <p>
                    El gráfico muestra claramente cómo la tasa de aprendizaje afecta la velocidad 
                    de convergencia, con α=0.001 requiriendo significativamente más épocas.
                </p>
            </div>
            
            <h3>◆ COMPARATIVA: IMPACTO DE LA TASA DE APRENDIZAJE (M1 vs M2)</h3>
            <div class="model-card">
                <h3>MODELO 1 vs MODELO 2</h3>
                <ul>
                    <li>Ambos usan las mismas 4 características</li>
                    <li>M1 usa α=0.01 (10x mayor que M2)</li>
                    <li>M2 usa α=0.001 (10x menor que M1)</li>
                    <li><strong>Resultado:</strong> M1 converge más rápido pero M2 es más estable</li>
                    <li>La tasa de aprendizaje alta reduce épocas necesarias</li>
                    <li>La tasa de aprendizaje baja ofrece ajuste más fino</li>
                </ul>
            </div>
            
            <h3>◆ COMPARATIVA: IMPACTO DE SELECCIÓN DE FEATURES (M1 vs M3)</h3>
            <div class="model-card">
                <h3>REDUCCIÓN DE 4 A 2 CARACTERÍSTICAS</h3>
                <ul>
                    <li>M1: 4 features (ejection_fraction, serum_creatinine, age, time)</li>
                    <li>M3: 2 features (ejection_fraction, serum_creatinine)</li>
                    <li><strong>Reducción:</strong> 50% menos características</li>
                    <li>M3 mantiene rendimiento competitivo con menos complejidad</li>
                    <li>Las 2 características más correlacionadas son suficientes</li>
                    <li>Eliminar 'age' y 'time' no degradó significativamente el modelo</li>
                </ul>
            </div>
            
            <h3>◆ MATRICES DE CONFUSIÓN</h3>
            <div class="model-card">
                <h3>ANÁLISIS DE CLASIFICACIÓN</h3>
                <p>
                    Se generaron matrices de confusión para los tres modelos en el conjunto de prueba:
                </p>
                <ul>
                    <li><strong>Clase 0 (No Muerte):</strong> Clase mayoritaria en el dataset</li>
                    <li><strong>Clase 1 (Muerte):</strong> Clase minoritaria, más difícil de predecir</li>
                    <li>Todos los modelos muestran mejor precisión en la clase mayoritaria</li>
                    <li>Desafío común: Balance entre sensibilidad y especificidad</li>
                    <li>La matriz revela verdaderos positivos, falsos positivos, etc.</li>
                </ul>
            </div>
            
            <h3>◆ EXPERIMENTOS ADICIONALES</h3>
            <div class="model-card">
                <h3>TASA DE APRENDIZAJE ALTA (α=0.5)</h3>
                <p>
                    Se realizó un experimento adicional con α=0.5 para comparar convergencia rápida:
                </p>
                <ul>
                    <li>Convergencia extremadamente rápida (pocas épocas)</li>
                    <li>Mayor riesgo de oscilaciones en los pesos</li>
                    <li>Puede sobrepasar la solución óptima</li>
                    <li>Útil para datasets grandes con muchas épocas</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>DECAIMIENTO ADAPTATIVO</h3>
                <p>
                    También se implementó un perceptrón con decaimiento de tasa de aprendizaje:
                </p>
                <ul>
                    <li><strong>Fórmula:</strong> α = α₀ / (1 + decay × época)</li>
                    <li>Comienza con pasos grandes (exploración)</li>
                    <li>Termina con pasos pequeños (ajuste fino)</li>
                    <li>Combina ventajas de tasas altas y bajas</li>
                    <li>Mejor balance entre velocidad y precisión</li>
                </ul>
            </div>
            
            <h3>◆ VISUALIZACIÓN: FRONTERA DE DECISIÓN (MODELO 3)</h3>
            <div class="model-card">
                <p>
                    El Modelo 3, al usar solo 2 características, permite visualizar la frontera 
                    de decisión lineal del perceptrón en un gráfico 2D. Esto facilita:
                </p>
                <ul>
                    <li>Interpretación visual de cómo clasifica el modelo</li>
                    <li>Identificación de puntos mal clasificados</li>
                    <li>Evaluación de la separabilidad lineal de las clases</li>
                    <li>Comprensión de las limitaciones del perceptrón simple</li>
                </ul>
            </div>
        </div>
        
        <!-- CONCLUSIONES -->
        <div id="conclusiones" class="content-section">
            <h2>► CONCLUSIONES</h2>
            
            <div class="conclusion-box">
                <h3>1. IDONEIDAD DEL PERCEPTRÓN PARA EL PROBLEMA</h3>
                <p>
                    El perceptrón simple demostró ser un modelo baseline efectivo para este 
                    problema de clasificación binaria médica. Sin embargo, su naturaleza 
                    lineal limita su capacidad para capturar relaciones complejas en datos 
                    clínicos. Los resultados sugieren que el problema tiene cierto grado de 
                    separabilidad lineal, pero no es perfectamente separable.
                </p>
            </div>
            
            <div class="conclusion-box">
                <h3>2. IMPACTO CRÍTICO DE LA TASA DE APRENDIZAJE (α)</h3>
                <p>
                    La comparación entre Modelo 1 (α=0.01) y Modelo 2 (α=0.001) reveló un 
                    trade-off fundamental: α alta acelera convergencia pero puede causar 
                    oscilaciones; α baja ofrece estabilidad pero requiere más épocas. 
                    El experimento con α=0.5 mostró convergencia extremadamente rápida pero 
                    con riesgo de inestabilidad. La implementación con decaimiento adaptativo 
                    demostró ser una solución óptima al combinar velocidad inicial con 
                    refinamiento progresivo.
                </p>
            </div>
            
            <div class="conclusion-box">
                <h3>3. SELECCIÓN DE CARACTERÍSTICAS: CALIDAD SOBRE CANTIDAD</h3>
                <p>
                    El Modelo 3, con solo 2 características (ejection_fraction y serum_creatinine), 
                    mantuvo un rendimiento competitivo frente a los modelos con 4 características. 
                    Esto valida el principio de que características bien seleccionadas y altamente 
                    correlacionadas superan a conjuntos más grandes con ruido. El análisis de 
                    correlación demostró ser una herramienta efectiva para feature selection.
                </p>
            </div>
            
            <div class="conclusion-box">
                <h3>4. VENTAJAS DE LA REDUCCIÓN DIMENSIONAL</h3>
                <p>
                    Reducir de 4 a 2 características (50%) no solo mantuvo el rendimiento, sino 
                    que permitió visualizar la frontera de decisión en 2D. Esta visualización 
                    proporcionó insights valiosos sobre la separabilidad lineal del problema y 
                    las limitaciones del perceptrón simple, facilitando la interpretabilidad 
                    del modelo en contexto médico.
                </p>
            </div>
            
            <div class="model-card">
                <h3>◆ LECCIONES APRENDIDAS</h3>
                <ul>
                    <li>El preprocesamiento (StandardScaler) es crucial para el perceptrón</li>
                    <li>La inicialización de pesos en cero es válida para el perceptrón</li>
                    <li>La regla de actualización target * net_input ≤ 0 es más robusta</li>
                    <li>Las etiquetas -1 y 1 facilitan la matemática del perceptrón</li>
                    <li>El análisis de correlación es fundamental para feature selection</li>
                    <li>Menos características pueden mejorar la generalización</li>
                    <li>La visualización 2D es invaluable para entender el modelo</li>
                    <li>El dataset de insuficiencia cardíaca tiene desbalance de clases</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>◆ COMPARACIÓN FINAL DE LOS TRES MODELOS</h3>
                <ul>
                    <li><strong>Modelo 1 (α=0.01, 4F):</strong> Balance óptimo, baseline sólido</li>
                    <li><strong>Modelo 2 (α=0.001, 4F):</strong> Mayor estabilidad, convergencia lenta</li>
                    <li><strong>Modelo 3 (α=0.01, 2F):</strong> Mejor interpretabilidad, eficiente</li>
                    <li><strong>Ganador general:</strong> Modelo 3 por balance rendimiento/complejidad</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>◆ LIMITACIONES IDENTIFICADAS</h3>
                <ul>
                    <li>El perceptrón simple no puede resolver problemas XOR</li>
                    <li>Sensible al desbalance de clases (más No-Muerte que Muerte)</li>
                    <li>No proporciona probabilidades, solo decisiones binarias</li>
                    <li>Requiere datos linealmente separables para convergencia perfecta</li>
                    <li>El dataset médico tiene ruido inherente que afecta la precisión</li>
                    <li>La frontera lineal es insuficiente para patrones complejos</li>
                </ul>
            </div>
            
            <div class="model-card">
                <h3>◆ RECOMENDACIONES FUTURAS</h3>
                <ul>
                    <li>Implementar perceptrón multicapa (MLP) para no-linealidad</li>
                    <li>Explorar técnicas de balanceo de clases (SMOTE, under/over-sampling)</li>
                    <li>Realizar validación cruzada k-fold para evaluación robusta</li>
                    <li>Implementar early stopping basado en conjunto de validación</li>
                    <li>Probar con más combinaciones de características (3, 5, 6 features)</li>
                    <li>Comparar con SVM, Logistic Regression, Random Forest</li>
                    <li>Aplicar técnicas de regularización para mejorar generalización</li>
                    <li>Experimentar con diferentes funciones de activación</li>
                </ul>
            </div>
            
            <div class="conclusion-box">
                <h3>▶ CONCLUSIÓN FINAL DEL PROYECTO</h3>
                <p>
                    Este proyecto logró implementar exitosamente tres variaciones del 
                    perceptrón desde cero, demostrando competencia en algoritmos fundamentales 
                    de Machine Learning. Los tres modelos revelaron insights valiosos:
                </p>
                <p>
                    <strong>1)</strong> La tasa de aprendizaje α es un hiperparámetro crítico 
                    que debe balancear velocidad y estabilidad. 
                    <strong>2)</strong> La selección inteligente de características (feature 
                    engineering) puede ser más impactante que usar todas las variables disponibles. 
                    <strong>3)</strong> La visualización y el análisis exploratorio son tan 
                    importantes como la implementación del algoritmo.
                </p>
                <p>
                    El Modelo 3 emergió como la solución más elegante: con solo 2 características 
                    cuidadosamente seleccionadas (ejection_fraction y serum_creatinine), logró 
                    mantener rendimiento competitivo mientras ganaba en interpretabilidad, 
                    eficiencia computacional y capacidad de visualización. Este resultado 
                    valida el principio fundamental del Machine Learning: la simplicidad bien 
                    ejecutada a menudo supera a la complejidad innecesaria.
                </p>
                <p>
                    Para aplicaciones médicas reales, se recomienda evolucionar hacia arquitecturas 
                    más complejas (MLP, ensemble methods) que puedan capturar las relaciones 
                    no-lineales inherentes a los datos clínicos, pero siempre manteniendo el 
                    perceptrón simple como baseline de referencia.
                </p>
            </div>
        </div>
    </div>
    
    <script>
        function showSection(sectionId) {
            const sections = document.querySelectorAll('.content-section');
            const buttons = document.querySelectorAll('.pixel-button');
            
            sections.forEach(section => section.classList.remove('active'));
            buttons.forEach(button => button.classList.remove('active'));
            
            document.getElementById(sectionId).classList.add('active');
            event.target.classList.add('active');
        }
    </script>
</body>
</html>